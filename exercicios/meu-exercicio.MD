## **PADR√ïES GOF DE CRIA√á√ÉO**

1. A classe `java.awt.Toolkit` √© um exemplo da aplica√ß√£o de que padr√£o de projeto?

   - Builder
   - <span style="color:green">Abstract Factory</span>
   - Prototype
   - Singleton
   - Factory Method

   > üí¨ O padr√£o Abstract Factory √© usado para criar fam√≠lias de objetos relacionados sem especificar suas classes concretas. A classe java.awt.Toolkit fornece uma interface para criar v√°rios objetos relacionados, como Image, Font, Color, etc., sem a necessidade de especificar as classes concretas desses objetos. Em vez disso, ele utiliza uma f√°brica abstrata para criar inst√¢ncias dos objetos apropriados, seguindo o conceito do padr√£o Abstract Factory. Desculpe pela confus√£o anterior e obrigado por esclarecer.

2. Analise o prop√≥sito a seguir:

   ''Implementar a instancia√ß√£o de objetos utilizando uma estrutura de heran√ßa, em que a superclasse define uma opera√ß√£o de cria√ß√£o de um produto gen√©rico, e cada subclasse define a implementa√ß√£o dessa opera√ß√£o, criando um produto espec√≠fico derivado do produto gen√©rico definido na superclasse''.

   Assinale a alternativa com o nome do padr√£o que possui esse prop√≥sito:

   - Abstract Factory
   - <span style="color:green">Factory Method</span>
   - Builder
   - Prototype
   - Singleton

   > O Factory Method √© usado para criar objetos, mas permite que as subclasses decidam qual classe concreta criar. Na descri√ß√£o, a superclasse define a opera√ß√£o de cria√ß√£o de um produto gen√©rico, e cada subclasse implementa essa opera√ß√£o para criar produtos espec√≠ficos derivados do produto gen√©rico definido na superclasse. Portanto, o Factory Method √© o padr√£o que atende a essa necessidade.

---

## **PADR√ïES GOF ESTRUTURAIS**

3. Voc√™ est√° desenvolvendo um sistema e percebe que est√° instanciando uma grande quantidade de objetos cujos atributos n√£o mudam de valor durante toda a execu√ß√£o do programa. Muitos desses objetos instanciados s√£o r√©plicas, o que gera uma utiliza√ß√£o muito ineficiente da mem√≥ria. Assinale a alternativa com o nome do padr√£o que poderia ser aplicado nesse cen√°rio:

   - <span style="color:green">Flyweight</span>
   - Decorator
   - Bridge
   - Singleton
   - Composite

   > üí¨ O padr√£o que pode ser aplicado nesse cen√°rio para economizar mem√≥ria ao lidar com objetos que possuem atributos inalter√°veis e muitas r√©plicas √© o padr√£o Flyweight. O padr√£o Flyweight √© projetado para minimizar o uso de mem√≥ria ou recursos, compartilhando objetos que s√£o semelhantes em vez de criar novas inst√¢ncias para cada ocorr√™ncia com os mesmos atributos imut√°veis. Isso √© √∫til quando voc√™ precisa lidar com uma grande quantidade de objetos com caracter√≠sticas comuns.

4. Assinale a alternativa com dois padr√µes que possuem uma estrutura de solu√ß√£o muito parecida, por√©m, com prop√≥sitos distintos.

   - Proxy e Composite.
   - Adapter e Composite.
   - <span style="color:green">Composite e Decorator.</span>
   - Proxy e Adapter.
   - Adapter e Decorator.

   > üí¨ Ambos os padr√µes, Composite e Decorator, possuem estruturas de solu√ß√£o muito parecidas, mas t√™m prop√≥sitos distintos. O padr√£o Composite √© usado para compor objetos em estruturas de √°rvore para representar hierarquias de parte-todo, enquanto o padr√£o Decorator √© usado para adicionar comportamentos ou responsabilidades adicionais a objetos individuais de forma flex√≠vel, sem alterar sua estrutura b√°sica.

---

## **PADR√ïES GOF COMPORTAMENTAIS**

5. Assinale a alternativa que expressa a inten√ß√£o do padr√£o de projeto Template Method:

   - <span style="color:green">Implementar a estrutura de um algoritmo gen√©rico em uma superclasse, considerando que os passos comuns s√£o implementados na pr√≥pria superclasse, enquanto os passos espec√≠ficos s√£o implementados nas suas subclasses.</span>
   - Encapsular uma fam√≠lia de algoritmos em objetos, permitindo que os m√≥dulos clientes possam utilizar esses algoritmos de forma intercambi√°vel.
   - Encapsular uma requisi√ß√£o em um objeto, permitindo o registro do hist√≥rico de requisi√ß√µes disparadas pelos m√≥dulos cliente e a cria√ß√£o de filas de requisi√ß√µes.
   - Permite capturar o estado interno de um objeto, permitindo que o seu estado seja restaurado posteriormente, sem quebrar o encapsulamento desse objeto.
   - Definir uma rela√ß√£o de depend√™ncia entre objetos, de modo a garantir que modifica√ß√µes no estado do objeto detentor da informa√ß√£o sejam notificadas automaticamente para os objetos inscritos previamente como interessados em receber essas notifica√ß√µes.

   > üí¨ Este padr√£o permite definir a estrutura geral de um algoritmo em uma superclasse e delegar a implementa√ß√£o de partes espec√≠ficas desse algoritmo para subclasses. Isso permite reutilizar o c√≥digo comum e personalizar o comportamento espec√≠fico em cada subclasse.

6. "Seja um cen√°rio em que existem v√°rios objetos capazes de realizar o processamento associado a uma requisi√ß√£o. Esses objetos s√£o organizados em uma lista encadeada de modo que a requisi√ß√£o vai sendo passada do primeiro objeto receptor da requisi√ß√£o para o pr√≥ximo da lista, e assim sucessivamente, at√© que o resultado desejado seja atingido".

   Assinale a alternativa com o nome do padr√£o com esse prop√≥sito:

   - Mediator
   - <span style="color:green">Chain of Responsibility</span>
   - Strategy
   - Command
   - Iterator

   > üí¨ O Chain of Responsibility √© usado quando voc√™ tem v√°rios objetos que podem processar uma requisi√ß√£o e esses objetos s√£o organizados em uma lista encadeada. A requisi√ß√£o √© passada do primeiro objeto receptor da requisi√ß√£o para o pr√≥ximo na lista, e assim por diante, at√© que o resultado desejado seja atingido ou at√© que nenhum objeto na cadeia seja capaz de processar a requisi√ß√£o. √â uma forma de desacoplar remetentes e destinat√°rios, permitindo que mais de um objeto tenha a chance de processar a requisi√ß√£o.

---

## **PADR√ïES GRASP**

7. Um m√≥dulo A cont√©m opera√ß√µes como convers√£o de medidas, formata√ß√£o de valores monet√°rios, remo√ß√£o de espa√ßos duplicados em strings e envio/recep√ß√£o de arquivos FTP.

   O m√≥dulo A possui coes√£o:

   - Temporal.
   - <span style="color:green">Coincidente.</span>
   - Funcional.
   - Sequencial.
   - Procedural.

   > üí¨ A coes√£o coincidente ocorre quando um m√≥dulo cont√©m opera√ß√µes que n√£o est√£o diretamente relacionadas, mas foram agrupadas por uma coincid√™ncia, como estar no mesmo m√≥dulo ou classe, por exemplo. No caso descrito, as opera√ß√µes de convers√£o de medidas, formata√ß√£o de valores monet√°rios, remo√ß√£o de espa√ßos duplicados em strings e envio/recep√ß√£o de arquivos FTP n√£o est√£o diretamente relacionadas por uma funcionalidade comum, mas foram agrupadas juntas em um √∫nico m√≥dulo por conveni√™ncia ou coincid√™ncia. Isso resulta em uma baixa coes√£o.

8. "Ao inv√©s de colocarmos o c√°lculo do frete de um pedido na classe Pedido, optamos por criar uma hierarquia de classes para encapsular os diferentes algoritmos de c√°lculo de frete que temos no sistema".

   Assinale a alternativa com o nome do padr√£o GRASP que recomenda a cria√ß√£o de classes que n√£o representam diretamente elementos concretos encontrados no dom√≠nio no neg√≥cio, seguindo uma decomposi√ß√£o de responsabilidades por comportamento e n√£o por representa√ß√£o, como a descrita no c√°lculo do frete.

   - Acoplamento Baixo.
   - Especialista na Informa√ß√£o.
   - <span style="color:green">Inven√ß√£o Pura.</span>
   - Indire√ß√£o.
   - Polimorfismo.

   > üí¨ O princ√≠pio da Inven√ß√£o Pura sugere que, em vez de colocar a responsabilidade em uma classe que n√£o √© naturalmente especialista em uma determinada funcionalidade (como a classe Pedido no caso do c√°lculo de frete), voc√™ deve criar uma nova classe que seja especializada na tarefa espec√≠fica (no caso, c√°lculo de frete) e atribuir essa responsabilidade a essa nova classe especializada. Isso ajuda a manter a coes√£o e o baixo acoplamento em seu sistema.

---

## **TECNOLOGIAS JPA E JEE**

1. A arquitetura MVC (Model, View e Controller) √© utilizada de forma ampla, na cria√ß√£o de sistemas cadastrais, e caracteriza-se pela divis√£o do sistema em tr√™s camadas, com objetivos espec√≠ficos. Considerando a divis√£o utilizada pelo MVC, a interface de usu√°rio e o componente DAO estariam, respectivamente, nas camadas:

   - <span style="color:green">View e Model</span>
   - Model e Controller
   - Controller e Model
   - Model e View
   - View e Controller

   > üí¨ Na arquitetura MVC (Model-View-Controller), a divis√£o √© a seguinte:
   >
   > Model: Lida com a l√≥gica de neg√≥cios e a manipula√ß√£o de dados.
   > View: Trata da interface de usu√°rio (UI) e da apresenta√ß√£o dos dados.
   > Controller: Controla o fluxo da aplica√ß√£o e atua como intermedi√°rio entre o Model e a View.

2. Ao trabalhar com um aplicativo corporativo, segundo a arquitetura MVC, ocorre uma divis√£o natural das camadas, em termos dos projetos internos, ficando a camada View sob responsabilidade do projeto com terminador "war". A interface padr√£o, conforme o pr√≥prio terminador indica, √© um aplicativo Java Web, sendo comum a implementa√ß√£o de um padr√£o de desenvolvimento para centralizar o tratamento das requisi√ß√µes, bem como redirecionar para a visualiza√ß√£o correta, ap√≥s efetuar as chamadas para a camada Controller. De qual padr√£o estamos falando, e qual o componente deve implement√°-lo?

   - Padr√£o de desenvolvimento Service Locator e componente do tipo JNDI
   - <span style="color:green">Padr√£o de desenvolvimento Front Controller e componente do tipo Servlet</span>
   - Padr√£o de desenvolvimento Flyweight e componente do tipo EJB
   - Padr√£o de desenvolvimento DAO e componente do tipo JPA
   - Padr√£o de desenvolvimento Facade e componente do tipo EJB

   > üí¨ O componente que geralmente implementa o Front Controller em aplicativos Java Web √© do tipo Servlet. O Servlet atua como um controlador central que recebe todas as solicita√ß√µes, decide qual Controller deve lidar com a solicita√ß√£o e, em seguida, encaminha a solicita√ß√£o para o Controller apropriado. Isso √© uma pr√°tica comum em aplicativos da web baseados em Java EE (Enterprise Edition). Portanto, a resposta correta √©:
